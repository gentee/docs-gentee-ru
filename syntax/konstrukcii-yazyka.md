

# Конструкции языка

Блок это последовательность определений и конструкций внутри фигурных скобок. Блоки могут вкладываться друг в друга.

```text
Block = "{" StatementList "}" .
StatementList = { Statement newline } .
Statement = ReturnStmt | IfStmt | Expression | WhileStmt | VarDeclaration | ForStmt | 
            LocalDecl | BreakStmt | ContinueStmt | SwitchStmt | GoStmt | TryStmt | 
            RecoverStmt | RetryStmt
```

## Определение переменной

Любая переменная функции должна быть описана перед её использованием. Определение переменной создает одну или несколько переменных и присваивает каждой начальные значения. Переменная может быть определена в любом блоке. Область видимости переменной распространяется на блок, в котором она определена и на все вложенные блоки. Нельзя создавать переменные с именем существующих функций и видимых переменных. Также, имя переменной должно содержать как минимум одну букву в нижнем регистре, так как имена в верхнем регистре используются для констант. Определение переменой начинается с указания её типа. Существует два типа инициализации - можно определить одну переменную с присваиванием ей значения или несколько переменных одного типа с инициализацией по умолчанию.

```text
VarDeclaration = VarAssign | VarList
VarList = TypeName ["?"] IdentifierList
VarAssign = TypeName ["?"] identifier "=" | "&=" VarInit
```

```text
int x y myVal
int z = myFunc(x) + y + 10
arr a &= b
```

Вы можете определить **опциональные параметры-переменные** указав **?** после типа переменной. Если вы инициализируете опциональный параметр оператором присваивания **=** или **&=**, то это будет его значение по умолчанию в том случае, если параметр не будет определен при вызове функции.  
Для того чтобы передать опциональный параметр при вызове функции, необходимо указать имя переменной и её значение через двоеточие. Опциональные параметры указываются после обычных параметров.

```text
func mul(int i) int {
      int ? j = 10
      return i*j
}

run int {
      return mul(7) + mul(5, j: 5)  // 70+25
}
```

## Конструкция if

Конструкции **if** начинаются с "if", они могут иметь один или несколько блоков "elif" и заканчиваться "else". Команда последовательно вычисляет условие для каждой ветки и, если условие возвращает истину, то тогда происходит выполнение соответствующего блока. В этом случае, остальные ветки пропускаются и управление передается следующей команде. Если условия во всех ветках ложны, то выполняется блок "else", если он существует.

```text
IfStmt = "if" Expression Block [{ "elif" Expression Block }][ "else" Block ]
```

```text
if a == 11 {
    b = 20
} else {
    c = a+b
}
if x > y && isOK { 
     x = 1 
} elif a > 1 {
   x++
} elif b < 10 {
    b = a
} else {x = 0}
```

## Конструкция while

Конструкция **while** является простым циклом. Данная конструкция выполняет блок до тех пор, пока логическое выражение равно истине. Если выражение ложно изначально \(при первом обращении\), то блок не будет выполнен ни разу.

```text
WhileStmt = "while" Expression Block
```

```text
a = 0
while a < 5 {
   с += a
   a++
}
```

## Конструкция for

Конструкция **for** служит для перебора всех элементов указанного объекта. Объект должен иметь тип, который поддерживает обращение по индексу, например, **arr**, **map**, **str**, **buf**, **set**, **range of integers**. Для каждого из его элементов выполняется код, который определен внутри конструкции. Вы должны указать имя переменной, которой будут присваиваться элементы и, опционально, имя переменной, которая будет равна текущему индексу.  
Если вы хотите перебрать целочисленные значения в указанном диапазоне, то используйте в качестве объекта запись **from..to**, где _from_ и _to_ значения типа _int_. Такой цикл будет перебирать все числа от _from_ до _to_, включая крайние значения. Начальное значение может быть больше конечного значения, в этом случае, значение на каждом цикле будет уменьшаться.

```text
ForStmt = "for" identifier [, identifier] "in" Expression Block
```

```text
str dest
for ch, i in `strΔ` {
   dest += "\{i}\{ch}"
}
int sum
for i in 0..100 : sum += i
```

## Конструкция switch

Конструкция **"switch"** позволяет производить разные действия в зависимости от значения выражения. После ключевого слова **switch** необходимо указать начальное выражение, значение которого будет сравниваться с различными вариантами в блоках **case**. Значение может иметь тип **int, float, char, str**. Затем вам нужно перечислить блоки **case** со всеми возможными значениями и соответствующим кодом в фигурных скобках, который необходимо будет выполнить в случае соответствия. Для одного **case** может быть указано несколько значений, разделённых запятыми. После выполнения **case** блока с найденными соответствием, программа заканчивает работу **switch** конструкции. Оставшиеся **case** блоки не проверяются.

Если вы хотите выполнить какие-то действия в случае, если подходящий вариант не найден, то укажите в конце блок **default**. Конструкция _default_ может быть только одна и идти после всех _case_ конструкций.

```text
SwitchStmt = "switch" Expression newline CaseStmt { CaseStmt } [ "default" Block ]
CaseStmt = "case" Expression {, Expression } Block
```

```text
int i = 67
int j
switch i+3 
case 20,10,5 {
  i +=10
}
case j,20+50,80 {
  i -=10
}
default: i *= 2
```

## Локальные функции local

Вы можете определять локальные функции **local** внутри функций **func**. Локальные функции могут принимать параметры и возвращать значения. Локальные функции не поддерживают переменное число аргументов. Для возврата из локальной функции необходимо использовать конструкцию **return**. В локальных функциях можно обращаться к внешним переменным и параметрам, которые были определены выше.

```text
LocalDecl   = "local" FunctionName [Parameters] [ Result ] Block
```

```text
run int {
    int i
    local loc(int step) int {
          return (i += 2)+step
    }
    return loc(1) + loc(2)*loc(3)
} 
// result: 57
```

## Конструкция return

Конструкция "return" прекращает выполнение текущей функции и может возвращать результирующее значение. Если у функции не указан результирующий тип, то конструкция "return" не должна возвращать значение. Вы можете использовать _return_ в любом вложенном блоке.

```text
ReturnStmt = "return" [ Expression ]
```

```text
func mul2(int i) int { return i*2}
```

## Конструкция break

Конструкция **break** используется для выхода из конструкции **switch/case** и циклов \(**for** и **while**\). **break** может быть внутри вложенных блоков. Если есть несколько вложенных циклов, то произойдёт выход из текущего цикла.

```text
BreakStmt = "break"
```

```text
while b > c {
   if !myfunc( b ) {
      break   
   }
   b++
}
```

## Конструкция continue

Конструкция "continue" действует внутри циклов \(**for** и **while**\) и позволяет перейти к выражению изменения счетчика для циклов _for_ или к выражению условию для _while_ не выполняя до конца тело цикла. В случае вложенных циклов инструкция действует на текущий цикл .

```text
ContinueStmt = "continue"
```

```text
for i in 0..100 {
   if i > 10 && i < 20 {
      continue 
   }
   a += i // Это выражение не вычисляется если i>10 и i<20
}
```


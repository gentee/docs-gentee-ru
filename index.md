---
nav: tocru
description: Описание синтаксиса и конструкций скриптового языка программирования Gentee.
---

# Синтаксис языка

## Лексические элементы

Исходный код должен быть в кодировке UTF-8. Синтаксис описан с использованием расширенной формы Бэкуса-Наура.

```text
newline        = 0x0A
unicode_char = /* Unicode code point */
unicode_linechar  = /* Unicode code point except newline */ 
unicode_letter = /* a Unicode code point classified as "Letter" */
letter        = unicode_letter | "_"
decimal_digit = "0" … "9" 
octal_digit   = "0" … "7" 
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" 
decimals  = decimal_digit { decimal_digit }
exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals
```

### Комментарии и замена символов

Имеются следующие типы комментариев и автоматически заменяемых символов

`// Однострочный комментарий`  
Однострочный комментарий начинается с двойного слеша `//` и заканчивается символом перевода строки _newline_.

`/* Общий комментарий */`  
Общий комментарий начинается с комбинации / _и заканчивается_ /. Такие комментарии могут вставляться где угодно.

`# Заголовок`  
В начале скрипта можно указать данные для использования в других программах. Такие комментарии должны идти подряд в каждой строке от начала скрипта. Можно не указывать '\#' в начале каждой строки, а вставить **\#\#\#** перед и после текста.

```text
#!/usr/local/bin/gentee
# первая строка может использоваться для запуска скрипта в Linux.
###
  desc = Description of the script
  result = ok
  var = value
###
```

**;**  
Символ перевода строки служит разделителем между выражениями и управляющими конструкциями. Точка с запятой заменяется на перевод строки. Таким образом, вы можете использовать точку с запятой, если вы хотите разместить несколько выражений на одной строке.

**:**  
Двоеточие заменяется на открывающую фигурную скобку и вставляется закрывающая фигурная скобка в конце текущей строки.

```text
// эти примеры эквивалентны
if a == 10 : a = b + c; c = d + e 

if a == 10 
{
   a = b + c
   c = d + e
}
```

### Идентификаторы

Идентификаторы - это имена, которые используются для обозначения переменных, типов, констант, функций и т.д.. Идентификатор определяется с помощью последовательности букв и цифр, но начинаться идентификатор должен с буквы.

```text
identifier = letter { letter | unicode_digit }
IdentifierList = identifier { identifier }
```

Имеется несколько предопределённых идентификаторов и ключевых слов. Следующие слова зарезервированы и не могут быть использованы в качестве идентификаторов.

#### Ключевые слова

**catch const elif else false for func go if in local recover retry return run struct true try while**

#### Предопределенные типы стандартной библиотеки

**arr bool buf char error finfo float int map range set str time trace thread**

### Литералы

Целочисленный литерал - это последовательность цифр представляющая целочисленное число \(константу\).

```text
decimal = ( "1" … "9" ) { decimal_digit } 
octal = "0" { octal_digit } .
hex = "0" ( "x" | "X" ) hex_digit { hex_digit } 
integer = decimal | octal | hex
float = decimals "." [ decimals ] [ exponent ] | decimals exponent
```

```text
0x34Fab
0722
19023862
0.123e+3
234.e-2
9.7732E-1
0.0177E+2
5e-2
```

Символьный _char_ литерал служит для идентификации Unicode символа. Вы можете указать один конкретный символ или последовательность символов начинающуюся с обратного слеша заключенные в одинарные кавычки. Последовательность символов с обратным слешем может иметь несколько форматов:

```text
'\r',  '\n',  '\t', '\"', '\'', '\\' 
\xa5 \x2B  (\x + two hex_digit)
\u03B1  (\u + four hex_digit)
\0371  (\0 + three octal_digit)
```

```text
byteVal  = octalStr | hexStr .
octalStr = `\` "0" octal_digit octal_digit octal_digit .
hexStr   = `\` "x" hex_digit hex_digit .
uShort   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
uLong    = `\` "U" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit .
escapedChar     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | `"` ) 
charLit         = "'" ( unicode_char | uShort | uLong | escapedChar | byteVal | `\'`) "'" .
```

Имеется два типа строковых литералов. 1. Строка в обратных кавычках может содержать любые символы. Если нужно указать обратную кавычку, то нужно удвоить её. 2. Строка в двойных кавычках также может содержать любые символы \(в том числе перенос строки\), но у неё имеется управляющий символ в виде обратной косой черты. Вы можете указывать после обратной косой черты следующие символы

```text
\a   U+0007 alert or bell  
\b   U+0008 backspace  
\f   U+000C form feed  
\n   U+000A newline  
\r   U+000D carriage return  
\t   U+0009 horizontal tab  
\v   U+000b vertical tab  
\\   U+005c backslash  
\"   U+0022 double quote
```

```text
stringLit         = stringBackQuote | stringDoubleQuote
stringBackQuote   = "`" { unicode_char | "%{" Expression "}" | "${" identifier "}" } "`"
stringDoubleQuote = `"` { unicode_char | uShort | uLong | escapedChar | byteVal | "\{" Expression "}" } `"`
```

В любой тип строки можно вставлять выражения. При этом тип выражения может быть любым, если имеется соответствующая функция приведения этого типа к строке. Выражения должны быть заключены в фигурные скобки со предшествующим знаком **%** \(для обратных кавычек\) или обратной косой чертой \(в случае двойных кавычек\).

```text
`10+20 equals %{10 + 20}. User name is "%{USERNAME}"`
"This is the first line.\r\nThis is \{ `the` + `second`} line."
```

## Типы

Тип описывает множество значений, которые имеют одинаковые операции и функции специально для этих значений. Тип определяется именем типа. Ассоциативный массив _map_ - это группа элементов одного типа к которой можно обращаться по строковому индексу. Каждый элемент имеет соответствующий уникальный строковый ключ. По умолчанию, массивы _arr_ и _map_ состоят из строк, но вы можете указать любую вложенность типов, разделив их точкой. Следует заметить, что переменные типов **arr**, **map**, **buf**, **set** и типов определенных с помощью **struct**, в отличии от прочих типов, передаются по ссылке, а не по значению. Это значит, что если внутри функции вы изменили значение такого параметра, то у вас изменится оригинальная переменная.

```text
TypeName  = identifier  { "." identifier }
```

Язык Gentee содержит следующие предопределенные типы.

| Имя | Описание | Значения | Начальное значение |
| :--- | :--- | :--- | :--- |
| **int** | 64-bit целочисленный тип | -9223372036854775808 .. 9223372036854775807 | 0 |
| **float** | 64-bit тип с плавающей точкой | 2.22 E–308 ..    1.79 E+308 | 0.0 |
| **bool** | логический тип | _true_ or _false_ | false |
| **str** | строка | последовательность байт | пустая строка |
| **char** | Unicode символ | Unicode символ int32 | пробел |
| **arr** | массив | массив элементов | пустой массив строк |
| **map** | ассоциативный массив | ассоциативный массив элементов | пустой ассоциативный массив строк |
| **buf** | массив байт | последовательность uint8 | пустой массив |
| **set** | массив bool | последовательность uint64 по 1 биту на значение | пустоe множество |

```text
arr.map.int a
map.arr.str b   // the same as map.arr b
map.bool c
arr.int  d
```

### Приведение типов

В языке Gentee отсутствует автоматическое приведение типов. Для основных типов имеются функции конвертирования из одного типа в другой, их имена совпадают с именем результирующего типа.

|  | int | bool | str | char | float |
| :--- | :--- | :--- | :--- | :--- | :--- |
| int |  | int\(false\) | int\("-23"\) | int\('A'\) | int\(3.24\) |
| bool | bool\(1\) |  | bool\("0"\) |  | bool\(1.1\) |
| str | str\(20\) | str\(false\) |  | str\('z'\) | str\(5.662\) |
| char |  |  |  |  |  |
| float | float\(10\) |  | float\("-2E-34"\) |  |  |

```text
int(false) // = 0           
int(true) // = 1    
bool(0) // = false  
bool(0.) // = false
bool(integer except zero) // = true    
bool("")  bool("0") bool("false") //=false
bool("not empty, zero or false string")   //=true
```

### Определение типа

Вы можете определить структурный тип с помощью ключевого слова **struct**. Укажите имя типа после ключевого слова и перечислите типы и имена полей внутри фигурных скобок. Все поля в переменной структурного типа инициализируются автоматически. Все переменные таких типов при передаче в функции передаются по ссылке, а не по значению. Для присваивания или получения значения поля, укажите его имя после точки.

```text
structDecl = "struct" identifier "{" FieldDecl { newline  FieldDecl } "}"
FieldDecl = TypeName identifier
FieldExpr = PrimaryExpr "." identifier
```

```text
struct my : int ID; str name
struct myStruct {
      int ID
      my myval
      arr st_arr
      map.int st_map
}
run int {
    myStruct ms
    ms.ID = 20
    return ms.ID * 2
}
```

### Тип функции

Язык Gentee позволяет работать с идентификаторами функций. Вы можете получить идентификатор функции, передать его в качестве параметра и вызвать соответствующую функцию. Для работы с идентификаторами функций вы должны определить тип функции с помощью ключевого слова **fn** и указать типы параметров и возвращаемого значения. Для получения идентификатора функции укажите **&имя**_**функции.fn**_**тип**. Идентификатор функции может передаваться в параметрах или присваиваться переменной соответствующего типа. Для вызова функции по её идентификатору достаточно указать имя переменной и круглые скобки с параметрами, как при вызове функции по имени.

```text
fnDecl = "fn" FnName [FnParameters] [ TypeName ]
FnName = identifier
FnParameters     = "(" [ FnParameterList ] ")"
FnParameterList  = TypeName { [","] TypeName }
FnIdent = "&" FuncName "." FnName
```

```text
fn bin( int int ) int
func add( int i, int j ) int : return i + j
func sub( int i, int j ) int : return i - j
func mybin(int i j, bin f ) int : return j + f(i, j)

run int {
  bin isub = &sub.bin
  return mybin(1, 2, &add.bin) + mybin(3, 7, isub)
}
```

## Описания

### Описание констант

Имя константы не должно содержать букв в нижнем регистре. Константам можно присваивать любые выражения. Значение константы вычисляется при первом обращении к данной константе, но тип константы автоматически определяется на этапе компиляции по типу присваиваемого выражения. Поэтому, несмотря на то, что тип при определении константы не указывается, действует проверка типов при её использовании.

```text
ConstDecl      = "const" ( ConstIota | ConstExp )
ConstIota = Expression "{" { IdentifierList newline } "}"
ConstExp = "{" { identifier "=" Expression newline } "}"
```

Константы можно определить двумя способами.

1. Указывая начальное значение или выражение для каждой константы.

   ```text
   const {
    MY_ID = 1
    MY_VAL = myFunc( MY_ID + 23)
    CHECK= MY_VAL < 32
   }
   ```

2. Используя общее выражение с **IOTA**. Иногда возникает необходимость определить список констант со значениями, которые вычисляются по определенным правилам. В этом случае, после ключевого слова **const** необходимо указать одно общее выражение, которая будет вычисляться для каждой константы в данном определении. В этом выражении можно использовать специальную переменную _IOTA_, которая равна порядковому индексу константы в списке с нуля. Сами константы могут перечисляться через пробел или с новой строки.

   ```text
   const 0x1 << IOTA {
      FIRST SECOND   // 0x1    0x2
      THIRD                   // 0x4
   }
   const (IOTA * 2) + 1 {
      MY1    // 1
      MY2   // 3
      MY3   // 5
   }
   ```

### Описание функции

Определение функции состоит из двух частей - описание параметров с возвращаемым типом и тела функции. При определении функции вы должны указать ключевое слово "func", имя функции, передаваемые параметры и тип возвращаемого значения. Только имя функции является обязательным элементом.

```text
FunctionDecl   = "func" FunctionName [Parameters] [ Result ] Block
FunctionName   = identifier 
Result         = TypeName 
Parameters     = "(" [ ParameterList ] ["..."] ")"
ParameterList  = VarList { "," VarList }
```

```text
func VariadicExample(int i, int s...) int {
    int sum = i*2
    for v in s {
       sum += v
    }
    return sum
}
func MyFunc(int par1 par2) int { 
    int par3 = VariadicExample(3, par1, par2, 4, 5, par1+par2)
    return (par1+par2 +par3)/3 
}
```

Заключительный параметр в описании функции может иметь суффикс _'...'_. Функция с таким параметром называется вариативной и может принимать ноль и более аргументов для этого параметра. Вы получаете этот параметр как массив переданных аргументов. Например, _int pars..._ означает, что _pars_ в действительности является _arr.int_ и вы можете получить i-й аргумент с помощью _pars\[i\]_.

### Описание функции запуска

Скрипт на языке Gentee должен содержать специальную функцию без параметров, которая определяется с помощью ключевого слова "run". Выполнение скрипта начинается с вызова этой функции. Скрипт должен иметь только одно определение "run".

```text
RunDecl = "run" [FunctionName] [ Result ] Block
```

```text
run int {
    int i ret
    while i < 10 {
       ret += myFunc(i++)
    }
    return ret
}
```

## Конструкции языка

Блок это последовательность определений и конструкций внутри фигурных скобок. Блоки могут вкладываться друг в друга.

```text
Block = "{" StatementList "}" .
StatementList = { Statement newline } .
Statement = ReturnStmt | IfStmt | Expression | WhileStmt | VarDeclaration | ForStmt | LocalDecl |
            BreakStmt | ContinueStmt | SwitchStmt | GoStmt | TryStmt | RecoverStmt | RetryStmt
```

### Определение переменной

Любая переменная функции должна быть описана перед её использованием. Определение переменной создает одну или несколько переменных и присваивает каждой начальные значения. Переменная может быть определена в любом блоке. Область видимости переменной распространяется на блок, в котором она определена и на все вложенные блоки. Нельзя создавать переменные с именем существующих функций и видимых переменных. Также, имя переменной должно содержать как минимум одну букву в нижнем регистре, так как имена в верхнем регистре используются для констант. Определение переменой начинается с указания её типа. Существует два типа инициализации - можно определить одну переменную с присваиванием ей значения или несколько переменных одного типа с инициализацией по умолчанию.

```text
VarDeclaration = VarAssign | VarList
VarList = TypeName ["?"] IdentifierList
VarAssign = TypeName ["?"] identifier "=" | "&=" VarInit
```

```text
int x y myVal
int z = myFunc(x) + y + 10
arr a &= b
```

Вы можете определить **опциональные параметры-переменные** указав **?** после типа переменной. Если вы инициализируете опциональный параметр оператором присваивания **=** или **&=**, то это будет его значение по умолчанию в том случае, если параметр не будет определен при вызове функции.  
Для того чтобы передать опциональный параметр при вызове функции, необходимо указать имя переменной и её значение через двоеточие. Опциональные параметры указываются после обычных параметров.

```text
func mul(int i) int {
      int ? j = 10
      return i*j
}

run int {
      return mul(7) + mul(5, j: 5)  // 70+25
}
```

### Конструкция if

Конструкции **if** начинаются с "if", они могут иметь один или несколько блоков "elif" и заканчиваться "else". Команда последовательно вычисляет условие для каждой ветки и, если условие возвращает истину, то тогда происходит выполнение соответствующего блока. В этом случае, остальные ветки пропускаются и управление передается следующей команде. Если условия во всех ветках ложны, то выполняется блок "else", если он существует.

```text
IfStmt = "if" Expression Block [{ "elif" Expression Block }][ "else" Block ]
```

```text
if a == 11 {
    b = 20
} else {
    c = a+b
}
if x > y && isOK { 
     x = 1 
} elif a > 1 {
   x++
} elif b < 10 {
    b = a
} else {x = 0}
```

### Конструкция while

Конструкция **while** является простым циклом. Данная конструкция выполняет блок до тех пор, пока логическое выражение равно истине. Если выражение ложно изначально \(при первом обращении\), то блок не будет выполнен ни разу.

```text
WhileStmt = "while" Expression Block
```

```text
a = 0
while a < 5 {
   с += a
   a++
}
```

### Конструкция for

Конструкция **for** служит для перебора всех элементов указанного объекта. Объект должен иметь тип, который поддерживает обращение по индексу, например, **arr**, **map**, **str**, **buf**, **set**, **range of integers**. Для каждого из его элементов выполняется код, который определен внутри конструкции. Вы должны указать имя переменной, которой будут присваиваться элементы и, опционально, имя переменной, которая будет равна текущему индексу.  
Если вы хотите перебрать целочисленные значения в указанном диапазоне, то используйте в качестве объекта запись **from..to**, где _from_ и _to_ значения типа _int_. Такой цикл будет перебирать все числа от _from_ до _to_, включая крайние значения. Начальное значение может быть больше конечного значения, в этом случае, значение на каждом цикле будет уменьшаться.

```text
ForStmt = "for" identifier [, identifier] "in" Expression Block
```

```text
str dest
for ch, i in `strΔ` {
   dest += "\{i}\{ch}"
}
int sum
for i in 0..100 : sum += i
```

### Конструкция switch

Конструкция **"switch"** позволяет производить разные действия в зависимости от значения выражения. После ключевого слова **switch** необходимо указать начальное выражение, значение которого будет сравниваться с различными вариантами в блоках **case**. Значение может иметь тип **int, float, char, str**. Затем вам нужно перечислить блоки **case** со всеми возможными значениями и соответствующим кодом в фигурных скобках, который необходимо будет выполнить в случае соответствия. Для одного **case** может быть указано несколько значений, разделённых запятыми. После выполнения **case** блока с найденными соответствием, программа заканчивает работу **switch** конструкции. Оставшиеся **case** блоки не проверяются.

Если вы хотите выполнить какие-то действия в случае, если подходящий вариант не найден, то укажите в конце блок **default**. Конструкция _default_ может быть только одна и идти после всех _case_ конструкций.

```text
SwitchStmt = "switch" Expression newline CaseStmt { CaseStmt } [ "default" Block ]
CaseStmt = "case" Expression {, Expression } Block
```

```text
int i = 67
int j
switch i+3 
case 20,10,5 {
  i +=10
}
case j,20+50,80 {
  i -=10
}
default: i *= 2
```

### Локальные функции local

Вы можете определять локальные функции **local** внутри функций **func**. Локальные функции могут принимать параметры и возвращать значения. Локальные функции не поддерживают переменное число аргументов. Для возврата из локальной функции необходимо использовать конструкцию **return**. В локальных функциях можно обращаться к внешним переменным и параметрам, которые были определены выше.

```text
LocalDecl   = "local" FunctionName [Parameters] [ Result ] Block
```

```text
run int {
    int i
    local loc(int step) int {
          return (i += 2)+step
    }
    return loc(1) + loc(2)*loc(3)
} 
// result: 57
```

### Конструкция return

Конструкция "return" прекращает выполнение текущей функции и может возвращать результирующее значение. Если у функции не указан результирующий тип, то конструкция "return" не должна возвращать значение. Вы можете использовать _return_ в любом вложенном блоке.

```text
ReturnStmt = "return" [ Expression ]
```

```text
func mul2(int i) int { return i*2}
```

### Конструкция break

Конструкция **break** используется для выхода из конструкции **switch/case** и циклов \(**for** и **while**\). **break** может быть внутри вложенных блоков. Если есть несколько вложенных циклов, то произойдёт выход из текущего цикла.

```text
BreakStmt = "break"
```

```text
while b > c {
   if !myfunc( b ) {
      break   
   }
   b++
}
```

### Конструкция continue

Конструкция "continue" действует внутри циклов \(**for** и **while**\) и позволяет перейти к выражению изменения счетчика для циклов _for_ или к выражению условию для _while_ не выполняя до конца тело цикла. В случае вложенных циклов инструкция действует на текущий цикл .

```text
ContinueStmt = "continue"
```

```text
for i in 0..100 {
   if i > 10 && i < 20 {
      continue 
   }
   a += i // Это выражение не вычисляется если i>10 и i<20
}
```

## Обработка ошибок

### Конструкция try catch

По умолчанию, если в момент выполнения скрипта была получена ошибка, то скрипт сразу заканчивает свою работу. Если вы хотите избежать прекращения работы скрипта, то вы должны использовать конструкцию **try**. Если во время выполнения кода внутри блока _try_ произошла ошибка, то управление перейдет в конструкцию **catch**, которая должна быть после **try**. После ключевого слова _catch_ необходимо указать имя переменной типа _error_, которая будет содержать информацию об ошибке. Вы можете использовать [специальные функции](https://gentee.github.io/docs-gentee-ru/stdlib/runtime#erriderror-err-int) для получения идентификатора и текста ошибки. Если вы не удалите ошибку внутри _catch_ с помощью **recover** или **retry**, то она будет передана дальше и скрипт закончит свою работу.

```text
TryStmt ="try" Block CatchStmt
CatchStmt = "catch" identifier Block
```

```text
run  {
   try {
      myfunc()
      error(101, "Custom error")
   }
   catch err {
      if ErrID(err) != 101:  error( 102, "Error \{ErrText(err)} has occurred in myfunc()")
   } 
}
```

### Конструкция recover

Конструкция **recover** используется внутри блока **catch** для удаления ошибки. По этой команде информация об ошибке удаляется, скрипт выходит из текущего блока _catch_ и продолжает выполнение дальше.

```text
RecoverStmt = "recover"
```

```text
run str {
   try : 10/0
   catch err :  recover
   return "ok"
} 
// ok
```

### Конструкция retry

Конструкция **retry** используется внутри блока **catch** для повторного запуска **try**. По этой команде информация об ошибке удаляется и скрипт заново выполняет соответствующий блок _try_.

```text
RetryStmt = "retry"
```

```text
run {
   str fname
   try {
       fname = ReadString("Specify filename: ")
       Println("Beginning of the file: ", str(ReadFile(fname, 0, 50)))
    } catch err {
       Println("ERROR #\{ErrID(err)}: \{ErrText(err)}")
       retry
    }
}
```

## Выражения

Выражение возвращает значение путем применения операторов и функций к операндам. Операндом может быть литерал, идентификатор определяющий константу, переменную, функцию или выражение в скобках. Для вызова функции необходимо указать её имя и в круглых скобках перечислить параметры через запятую. Параметры тоже могут быть выражениями.

```text
Operand     = Literal | OperandName | "(" Expression ")" | GoStmt
Literal     = BasicLiteral
constLit    = "true" | "false"
BasicLiteral    = float | integer | stringLit | constLit | charLit
OperandName = identifier | EnvVariable | FnIdent
PrimaryExpr = Operand |    FuncName Arguments | IfOp | IndexExp | FieldExpr
OptionalArgs = identifier ":" Expression { "," identifier ":" Expression }
Arguments    = "(" [ ExpressionList ] [ OptionalArgs ] ")" 
ExpressionList = Expression { "," Expression } 
Expression = UnaryExpr | Expression binaryOp Expression | OperandName assignOp Expression
UnaryExpr  = PrimaryExpr | unaryOp UnaryExpr | incOp OperandName | OperandName incOp 
binaryOp  = "||" | "&&" | relOp | mathOp | assignOp | rangeOp
relOp     = "==" | "!=" | "<" | "<=" | ">" | ">=" 
mathOp     = "+" | "-" | "|" | "^" | "*" | "/" | "%" | "<<" | ">>" | "&" | 
unaryOp   = "-" | "!" | "^" | "*" | "#" | "##"
incOp = "++" | "--" 
rangeOp = ".."
assignOp = "=" | "+=" | "-=" | "|=" | "^=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "#=" 
IfOp = "?" "(" Expression "," Expression "," Expression ")"
```

При вычислении логических операторов "&&" \(И\) и "\|\|" \(ИЛИ\), правый операнд вычисляется опционально. Например, в случаях `false && myFunc()` и `true || myFunc()` функция myFunc не будет вызываться.

Операторы присваивания являются бинарными операторами, которые возвращают присвоенное значение. Таким образом операторы присваивания могут использоваться внутри выражений.

```text
int i j k
i = j = 5+(k=60/5)*2
return (k+j)*2 + i   // 111
```

### Приоритеты операторов

Как правило все операторы выполняются слева направо, но имеется такое понятие как приоритет операторов. Если следующий оператор имеет более высокий приоритет, то вначале выполнится оператор с более высоким приоритетом. Например, умножение имеет более высокий приоритет и 4 + 5 _2 равно 14, но если мы поставим круглые скобки то \( 4 + 5 \)_ 2 равно 18.

| Оператор | Тип | Ассоциативность |
| :--- | :--- | :--- |
| Высший приоритет |  |  |
| \(   \)  \[   \] |  | Слева направо |
| !   -   ^   \#   \#\#   \*   ++   -- | Унарный префикс | Справа налево |
| ++   -- | Унарный постфикс | Слева направо |
| /   %   \* | Бинарный | Слева направо |
| +   - | Бинарный | Слева направо |
| &lt;&lt;   &gt;&gt; | Бинарный | Слева направо |
| & | Бинарный | Слева направо |
| ^ | Бинарный | Слева направо |
| \| | Бинарный | Слева направо |
| ==   !=   &lt;   &lt;=   &gt;   &gt;= | Бинарный | Слева направо |
| \|\| | Бинарный | Слева направо |
| && | Бинарный | Слева направо |
| \#= | Бинарный | Слева направо |
| =   +=   -=   \*=   /=   %=   &lt;&lt;=   &gt;&gt;=   &=   ^=   \|= | Бинарный | Справа налево |
| .. | Бинарный | Слева направо |
| Низший приоритет |  |  |

Круглые скобки \(\) изменяют порядок вычисления частей выражения. Операции инкремента ++ и -- могут быть как префиксными, так и постфиксными.

### Условный оператор "?"

Условный оператор "?" аналогичен по своей работе конструкции "if", но может использоваться внутри выражения. Он содержит три операнда-выражения. Операнды заключены в скобки и разделены запятыми, вначале вычисляется значение первого логического \(целочисленного\) выражения. Если значение истинно, то вычисляется второе выражение и полученное значение становится результатом работы условного оператора. В противном случае вычисляется третий операнд и возвращается его значение.

```text
if a >= ?( x, 0xFFF, ?( y < 5 && y > 2, y, 2*b )) + 2345
{
     r = ?( a == 10, a, a + b ) 
}
```

### Инициализация массивов и структур

При определении переменных с типом _arr_, _set_, _buf_ или _map_ можно сразу присвоить элементы массива. Также можно указывать значения полей переменных структурных типов. Значения перечисляются через запятую или перенос строки. В качестве значения можно указывать выражения. При инициализации ассоциативного массива _map_ необходимо указать ключ в виде строки и через двоеточие значение. Если элементами массива являются другие массивы, то они тоже инициализируются с помощью фигурных скобок. При инициализации полей структур необходимо указать ключ в виде идентификатора и через двоеточие значение. Переменная типа **buf** может инициализироваться комбинацией значений типов **int**, **str**, **char**, **buf**.

```text
DelimInit = "," | newline
ArrInit = "{" VarInit {DelimInit VarInit} "}"
BufInit = "{" Expression {DelimInit Expression} "}"
MapInit = "{" Expression ":" VarInit { DelimInit Expression ":" VarInit  }  "}"
SetInit = "{" Expression {DelimInit Expression} "}"
StructInit = "{" identifier ":" VarInit { DelimInit identifier ":" VarInit  }  "}"
VarInit = ArrInit | BufInit | MapInit | StructInit | SetInit | Expression
```

```text
mystruct my = {ID: 20, name: "some text"}
buf a = {250+5, '1', 'A', "test", 0}
map.arr.int ret = {"key1": {0, 1 }, `key2`:{ 2, 3 } }
arr.map ret = { {"test": "value 1"}
                {`next`:"value 2"} }
arr.bool mb = : true, false, true
map  my = {"key1": GetVal(1), "key2": GetVal(2)}
set s &= {1, 0, 45, myintval, MYCONST}
```

### Индексное выражение

Индексы позволяют вам получать или устанавливать определенный элемент переменной по его индексу. Индекс - это позиция определенного элемента внутри указанной переменной. Индексы в Gentee начинаются с нуля \(для **map** индексы имеют строковый тип\), первый элемент имеет индекс 0, второй индекс один и т.д. Следующие типы поддерживают индексы:

* **str**. Индекс должен иметь тип **int** и быть меньше длины строки. Если индекс выходит за этот диапазон, то возникает ошибка выполнения. Результат имеет тип **char**.
* **buf**. Индекс должен иметь тип **int** и быть меньше длины массива. Если индекс выходит за этот диапазон, то возникает ошибка выполнения. Результат имеет тип **int**, но 0 &lt;= значение &lt;= 255.
* **arr**. Индекс должен иметь тип **int** и быть меньше длины массива. Если индекс выходит за этот диапазон, то возникает ошибка выполнения. Результат имеет такой же тип, как тип элементов массива.
* **map**. Индекс должен иметь тип **str**. В случае получения значения, элемент с таким индексом должен существовать в ассоциативном массиве. Если такой ключ отсутствует, то возникает ошибка выполнения. Результат имеет такой же тип, как тип элементов ассоциативного массива.
* **set**. Индекс должен иметь тип **int** и быть меньше 64000000. Если индекс выходит за этот диапазон, то возникает ошибка выполнения. Результат имеет логический тип.

Если массив _array_ или _map_ состоит из массивов, то вы можете последовательно применить индексные выражения.

```text
IndexExp = PrimaryExpr "[" Expression "]" { "[" Expression "]" }
```

```text
str temp = `0123`
temp[1] = temp[3]  // result `0323`
arr ain
ain += `test`
temp = ain[0]
map mymap
mymap["mykey"] = "myvalue"
arr.map amap
amap += mymap
amap[0]["mykey"] = "new value"
```

### Выражения присваивания

Для всех типов в языке Gentee существует оператор присваивания **=**. При использовании присваивания для типов **buf, arr, map, set** и всех структурных типов вы будете получать копии данных. Рассмотрим пример

```text
arr a1 = {`A`, `B`, `C`}
arr a2 = a1
a2 += `D`
a1[0] = `Z`
//  a1 = `Z`, `B`, `C`
//  a2 = `A`, `B`, `C`, `D`
```

При присваивании _a2 = a1_ мы получили копию массива _a1_. Действия над массивами никак не будут влиять друг на друга. Иногда создание копий больших объектов может замедлять выполнение программы. Например, если функция возвращает какую-то структуру, с которой нужно работать дальше, то нет смысла создавать её копию. Для разрешения таких ситуаций, для типов **buf, arr, map, set** и всех структурных типов имеется еще один оператор присваивания **&=**. Этот оператор не копирует данные в переменную, а создает клон этих данных. В этом случае, данные остаются в единственном экземпляре.

```text
arr a1 = {`A`, `B`, `C`}
arr a2 &= a1
a2 += `D`
a1[0] = `Z`
//  a1 = `Z`, `B`, `C`, `D`
//  a2 = `Z`, `B`, `C`, `D`
```

```text
time t
t &= Now()  // так лучше, чем  t = Now()
```

### Контекст

В языке Gentee отсутствуют глобальные переменные. Вместо них имеется ассоциативный массив _map.str_, который доступен на чтение и запись из любых функций и потоков. Кроме хранения данных в виде ключ-значение, контекст может ещё производить рекурсивную замену ключей в строках вида _"\#key\_name\# \#another\_key\_name\#"_. Все [функции для работы с контекстом](https://gentee.github.io/docs-gentee-ru/stdlib/context) описаны в стандартной библиотеке. Здесь рассмотрим только операторы.

* Унарный оператор **\#\# str** рекурсивно заменяет ключи на их значения  в переданной строке и возвращает полученный результат. 
* Унарный оператор **\# key** работает аналогично оператору **\#\#**, но ему нужно передать имя-идентификатор ключа контекста.
* Оператор **key \#= value** записывает в контекст  ключ _key_ с указанным  значением. Если вместо типа _str_ значение имеет тип _int, bool, float_, то оно будет сконвертировано в строку.

```text
func ooops() {
    AB #= `oops`
}
run str {
    AB #= `test`
    CD #= `#AB# - `    // don't replace #AB#.  CD = #AB# - 
    E #= #AB           // get #AB#. E = test
    ooops()            // change AB
    val #= 10
    return #CD + #E + ##` #val# == 10`
}
// Result:  oops - test 10 == 10
```

## Запуск программ

В языке Gentee существует специальная команда **$** для запуска приложений и команд операционной системы с указанными параметрами. Данная команда запускает весь следующий за ней текст до конца строки. Между символом **$** и командной строкой должен присутствовать пробел. Если данная команда используется в выражении, то она перехватывает стандартный вывод и возвращает его в виде строки. В противном случае, стандартный вывод будет виден в консоли. Можно использовать подстановку выражений с помощью **%{Expression}** как в строке с обратными кавычками. Если какой-то параметр содержит пробел, то его нужно заключить в любые кавычки - _"a b", 'c d', \`e f\`_. Если запускаемое приложение или команда завершилось с кодом ошибки, отличным от нуля, то скрипт также прекратит работу и возвратит ошибку.

```text
Command = "$ " { unicode_linechar | "%{" Expression "}" | "${" identifier "}" }
```

```text
run str {
   $ dir
   str name = $ echo "John Smith"
   return $ echo My name is %{name}
}
```

### Переменные окружения

Язык Gentee позволяет вам легко получать и присваивать значения переменных окружения. Для этого укажите знак **$** перед именем переменной. Кроме этого, вы можете подставлять переменные окружения с помощью конструкции **${ENV\_NAME}** в командах запуска **$** и строках с обратными кавычками. Эта запись короче, чем _%{ $ENV\_NAME }_. Переменные окружения всегда имеют строковый тип, но вы можете присваивать им значения типа **str**, **int** и **bool**.

```text
EnvVariable = "$" identifier
```

```text
run str {
    $MYVAR = `Go path: ${GOPATH}` + $GOROOT
    return $ echo ${MYVAR}
}
```

## Многопоточность

Язык Gentee позволяет создавать многопоточные скрипты. В этом случае, часть скрипа может выполняться параллельно, что уменьшает время его работы. Чтобы выполнить какой-то код в отдельном потоке, необходимо указать его в конструкции **go**. Скрипт продолжит выполнять следующие конструкции не дожидаясь окончания работы кода внутри _go_, а сразу после того как новый поток будет запущен. Конструкция **go** возвращает идентификатор созданного потока, который можно присвоить переменной типа **thread** и использовать затем в функциях управления потоками. Если скрипт закончил свою работу раньше чем созданные потоки, то он будет ожидать окончания работы всех потоков. Если при выполнении многопоточного скрипта произошла ошибка в любом из потоков, то в этом случае, все потоки закрываются и скрипт возвращает эту ошибку.

```text
GoStmt = "go" [ "(" GoArgs ")" ] Block
GoArgs = identifier ":" Expression { "," identifier ":" Expression }
```

```text
func myThread {
  for i in 0..50 {
    Print(`x` )
    if i % 3 == 0 : sleep(5)
  }
}

run {
  thread th = go {
    for i in 0..100 {
      Print(` `, i )
      if i % 7 == 0 : sleep(5)
    }
  }
  suspend( th )
  go : myThread()
  resume(th)
  Print( `OK`)
  wait(th)
  Print( `END`)
}
```

Вы можете передавать любые параметры в команде **go**. Для этого необходимо указать имя параметра и, через двоеточие, его значение. Тип параметра определяется автоматически по переданному значению. Если вы передаете структуры или массивы, то параметру будет присвоена копия значения.

```text
run str {
  str s = "ok"
  thread th1 = go (a: s + " test") : ctxPar #= a
  thread th2 = go (a: Max(1,23), b: Min(100,87)) {
     ctxSum #= a + b
  }
  wait(th2)
  wait(th1)
  return #ctxPar + #ctxSum
}
```

## Include и import

### Включение файлов

Описание **include** импортирует все типы, функции и константы из указанных файлов и их дочерних файлов включенных с помощью **include**.

Описание **import** импортирует только публичные типы, функции и константы из указанных файлов и их дочерних файлов включенных с помощью **include**. Публичные объекты определяются с помощью ключевого слова **pub**.

```text
stringConst         = "`" { unicode_char } "`" | stringDoubleConst
stringDoubleConst = `"` { unicode_char | uShort | uLong | escapedChar | byteVal } `"`
importDecl = "import" "{" {stringConst newline} "}"
includeDecl = "include" "{" {stringConst newline} "}"
```

Рассмотрим видимость объектов в виде таблицы. Пусть имеется два файла.

```text
// a.g can include or import b.g
func afunc(i int) : return i*2
pub func apubfunc(i int) : return i*3

// b.g 
func bfunc(i int) : return i*4
pub func bpubfunc(i int) : return i*5
```

Пусть файл _c.g_ может импортировать или включать файл _a.g_. Вы можете видеть какие функции будут видимы в файле _c.g_ в зависимости от различных ситуаций.

|  | include a   a includes b | include a   a imports b | import a   a includes b | import a   a imports b |
| :--- | :--- | :--- | :--- | :--- |
| afunc | visible | visible |  |  |
| apubfunc | visible | visible | visible | visible |
| bfunc | visible |  |  |  |
| bpubfunc | visible |  | visible |  |

### Описание pub

Команда **pub** определяет следующую функцию, тип или константы как публичные. Вы можете импортировать их с помощью команды **import**.

```text
pubDecl = "pub" [newline]
objects = [pubDecl] (structDecl | FnDecl | ConstDecl | FunctionDecl)
```

Ключевое слово **pub** указывает, что следующая функция, константы или тип будут передаваться в случае импорта файла.

```text
pub const IOTA {  // public constants. Visible when include or import
    MY1
    MY2
}

const IOTA*2 {  // private constants. Visible only when include
    MY3
    MY4
}
```

